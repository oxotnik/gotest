// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package models

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"glm-go-project/model"
)

func newLibraryStyle(db *gorm.DB, opts ...gen.DOOption) libraryStyle {
	_libraryStyle := libraryStyle{}

	_libraryStyle.libraryStyleDo.UseDB(db, opts...)
	_libraryStyle.libraryStyleDo.UseModel(&model.LibraryStyle{})

	tableName := _libraryStyle.libraryStyleDo.TableName()
	_libraryStyle.ALL = field.NewAsterisk(tableName)
	_libraryStyle.ID = field.NewInt32(tableName, "id")
	_libraryStyle.DateCreate = field.NewTime(tableName, "date_create")
	_libraryStyle.DateLastChange = field.NewTime(tableName, "date_last_change")
	_libraryStyle.CreaterID = field.NewInt64(tableName, "creater_id")
	_libraryStyle.ChangerID = field.NewInt64(tableName, "changer_id")
	_libraryStyle.IsArchive = field.NewBool(tableName, "is_archive")
	_libraryStyle.Title = field.NewString(tableName, "title")
	_libraryStyle.TypeStyle = field.NewString(tableName, "type_style")
	_libraryStyle.Style = field.NewString(tableName, "style")
	_libraryStyle.CategoryID = field.NewInt32(tableName, "category_id")
	_libraryStyle.ProjectID = field.NewInt32(tableName, "project_id")
	_libraryStyle.ParentID = field.NewInt32(tableName, "parent_id")
	_libraryStyle.IsCategory = field.NewBool(tableName, "is_category")
	_libraryStyle.TemplateStyleID = field.NewInt32(tableName, "template_style_id")

	_libraryStyle.fillFieldMap()

	return _libraryStyle
}

type libraryStyle struct {
	libraryStyleDo

	ALL             field.Asterisk
	ID              field.Int32
	DateCreate      field.Time
	DateLastChange  field.Time
	CreaterID       field.Int64
	ChangerID       field.Int64
	IsArchive       field.Bool
	Title           field.String
	TypeStyle       field.String
	Style           field.String
	CategoryID      field.Int32
	ProjectID       field.Int32
	ParentID        field.Int32
	IsCategory      field.Bool
	TemplateStyleID field.Int32

	fieldMap map[string]field.Expr
}

func (l libraryStyle) Table(newTableName string) *libraryStyle {
	l.libraryStyleDo.UseTable(newTableName)
	return l.updateTableName(newTableName)
}

func (l libraryStyle) As(alias string) *libraryStyle {
	l.libraryStyleDo.DO = *(l.libraryStyleDo.As(alias).(*gen.DO))
	return l.updateTableName(alias)
}

func (l *libraryStyle) updateTableName(table string) *libraryStyle {
	l.ALL = field.NewAsterisk(table)
	l.ID = field.NewInt32(table, "id")
	l.DateCreate = field.NewTime(table, "date_create")
	l.DateLastChange = field.NewTime(table, "date_last_change")
	l.CreaterID = field.NewInt64(table, "creater_id")
	l.ChangerID = field.NewInt64(table, "changer_id")
	l.IsArchive = field.NewBool(table, "is_archive")
	l.Title = field.NewString(table, "title")
	l.TypeStyle = field.NewString(table, "type_style")
	l.Style = field.NewString(table, "style")
	l.CategoryID = field.NewInt32(table, "category_id")
	l.ProjectID = field.NewInt32(table, "project_id")
	l.ParentID = field.NewInt32(table, "parent_id")
	l.IsCategory = field.NewBool(table, "is_category")
	l.TemplateStyleID = field.NewInt32(table, "template_style_id")

	l.fillFieldMap()

	return l
}

func (l *libraryStyle) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := l.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (l *libraryStyle) fillFieldMap() {
	l.fieldMap = make(map[string]field.Expr, 14)
	l.fieldMap["id"] = l.ID
	l.fieldMap["date_create"] = l.DateCreate
	l.fieldMap["date_last_change"] = l.DateLastChange
	l.fieldMap["creater_id"] = l.CreaterID
	l.fieldMap["changer_id"] = l.ChangerID
	l.fieldMap["is_archive"] = l.IsArchive
	l.fieldMap["title"] = l.Title
	l.fieldMap["type_style"] = l.TypeStyle
	l.fieldMap["style"] = l.Style
	l.fieldMap["category_id"] = l.CategoryID
	l.fieldMap["project_id"] = l.ProjectID
	l.fieldMap["parent_id"] = l.ParentID
	l.fieldMap["is_category"] = l.IsCategory
	l.fieldMap["template_style_id"] = l.TemplateStyleID
}

func (l libraryStyle) clone(db *gorm.DB) libraryStyle {
	l.libraryStyleDo.ReplaceConnPool(db.Statement.ConnPool)
	return l
}

func (l libraryStyle) replaceDB(db *gorm.DB) libraryStyle {
	l.libraryStyleDo.ReplaceDB(db)
	return l
}

type libraryStyleDo struct{ gen.DO }

type ILibraryStyleDo interface {
	gen.SubQuery
	Debug() ILibraryStyleDo
	WithContext(ctx context.Context) ILibraryStyleDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ILibraryStyleDo
	WriteDB() ILibraryStyleDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ILibraryStyleDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ILibraryStyleDo
	Not(conds ...gen.Condition) ILibraryStyleDo
	Or(conds ...gen.Condition) ILibraryStyleDo
	Select(conds ...field.Expr) ILibraryStyleDo
	Where(conds ...gen.Condition) ILibraryStyleDo
	Order(conds ...field.Expr) ILibraryStyleDo
	Distinct(cols ...field.Expr) ILibraryStyleDo
	Omit(cols ...field.Expr) ILibraryStyleDo
	Join(table schema.Tabler, on ...field.Expr) ILibraryStyleDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ILibraryStyleDo
	RightJoin(table schema.Tabler, on ...field.Expr) ILibraryStyleDo
	Group(cols ...field.Expr) ILibraryStyleDo
	Having(conds ...gen.Condition) ILibraryStyleDo
	Limit(limit int) ILibraryStyleDo
	Offset(offset int) ILibraryStyleDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ILibraryStyleDo
	Unscoped() ILibraryStyleDo
	Create(values ...*model.LibraryStyle) error
	CreateInBatches(values []*model.LibraryStyle, batchSize int) error
	Save(values ...*model.LibraryStyle) error
	First() (*model.LibraryStyle, error)
	Take() (*model.LibraryStyle, error)
	Last() (*model.LibraryStyle, error)
	Find() ([]*model.LibraryStyle, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.LibraryStyle, err error)
	FindInBatches(result *[]*model.LibraryStyle, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.LibraryStyle) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ILibraryStyleDo
	Assign(attrs ...field.AssignExpr) ILibraryStyleDo
	Joins(fields ...field.RelationField) ILibraryStyleDo
	Preload(fields ...field.RelationField) ILibraryStyleDo
	FirstOrInit() (*model.LibraryStyle, error)
	FirstOrCreate() (*model.LibraryStyle, error)
	FindByPage(offset int, limit int) (result []*model.LibraryStyle, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ILibraryStyleDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (l libraryStyleDo) Debug() ILibraryStyleDo {
	return l.withDO(l.DO.Debug())
}

func (l libraryStyleDo) WithContext(ctx context.Context) ILibraryStyleDo {
	return l.withDO(l.DO.WithContext(ctx))
}

func (l libraryStyleDo) ReadDB() ILibraryStyleDo {
	return l.Clauses(dbresolver.Read)
}

func (l libraryStyleDo) WriteDB() ILibraryStyleDo {
	return l.Clauses(dbresolver.Write)
}

func (l libraryStyleDo) Session(config *gorm.Session) ILibraryStyleDo {
	return l.withDO(l.DO.Session(config))
}

func (l libraryStyleDo) Clauses(conds ...clause.Expression) ILibraryStyleDo {
	return l.withDO(l.DO.Clauses(conds...))
}

func (l libraryStyleDo) Returning(value interface{}, columns ...string) ILibraryStyleDo {
	return l.withDO(l.DO.Returning(value, columns...))
}

func (l libraryStyleDo) Not(conds ...gen.Condition) ILibraryStyleDo {
	return l.withDO(l.DO.Not(conds...))
}

func (l libraryStyleDo) Or(conds ...gen.Condition) ILibraryStyleDo {
	return l.withDO(l.DO.Or(conds...))
}

func (l libraryStyleDo) Select(conds ...field.Expr) ILibraryStyleDo {
	return l.withDO(l.DO.Select(conds...))
}

func (l libraryStyleDo) Where(conds ...gen.Condition) ILibraryStyleDo {
	return l.withDO(l.DO.Where(conds...))
}

func (l libraryStyleDo) Order(conds ...field.Expr) ILibraryStyleDo {
	return l.withDO(l.DO.Order(conds...))
}

func (l libraryStyleDo) Distinct(cols ...field.Expr) ILibraryStyleDo {
	return l.withDO(l.DO.Distinct(cols...))
}

func (l libraryStyleDo) Omit(cols ...field.Expr) ILibraryStyleDo {
	return l.withDO(l.DO.Omit(cols...))
}

func (l libraryStyleDo) Join(table schema.Tabler, on ...field.Expr) ILibraryStyleDo {
	return l.withDO(l.DO.Join(table, on...))
}

func (l libraryStyleDo) LeftJoin(table schema.Tabler, on ...field.Expr) ILibraryStyleDo {
	return l.withDO(l.DO.LeftJoin(table, on...))
}

func (l libraryStyleDo) RightJoin(table schema.Tabler, on ...field.Expr) ILibraryStyleDo {
	return l.withDO(l.DO.RightJoin(table, on...))
}

func (l libraryStyleDo) Group(cols ...field.Expr) ILibraryStyleDo {
	return l.withDO(l.DO.Group(cols...))
}

func (l libraryStyleDo) Having(conds ...gen.Condition) ILibraryStyleDo {
	return l.withDO(l.DO.Having(conds...))
}

func (l libraryStyleDo) Limit(limit int) ILibraryStyleDo {
	return l.withDO(l.DO.Limit(limit))
}

func (l libraryStyleDo) Offset(offset int) ILibraryStyleDo {
	return l.withDO(l.DO.Offset(offset))
}

func (l libraryStyleDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ILibraryStyleDo {
	return l.withDO(l.DO.Scopes(funcs...))
}

func (l libraryStyleDo) Unscoped() ILibraryStyleDo {
	return l.withDO(l.DO.Unscoped())
}

func (l libraryStyleDo) Create(values ...*model.LibraryStyle) error {
	if len(values) == 0 {
		return nil
	}
	return l.DO.Create(values)
}

func (l libraryStyleDo) CreateInBatches(values []*model.LibraryStyle, batchSize int) error {
	return l.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (l libraryStyleDo) Save(values ...*model.LibraryStyle) error {
	if len(values) == 0 {
		return nil
	}
	return l.DO.Save(values)
}

func (l libraryStyleDo) First() (*model.LibraryStyle, error) {
	if result, err := l.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.LibraryStyle), nil
	}
}

func (l libraryStyleDo) Take() (*model.LibraryStyle, error) {
	if result, err := l.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.LibraryStyle), nil
	}
}

func (l libraryStyleDo) Last() (*model.LibraryStyle, error) {
	if result, err := l.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.LibraryStyle), nil
	}
}

func (l libraryStyleDo) Find() ([]*model.LibraryStyle, error) {
	result, err := l.DO.Find()
	return result.([]*model.LibraryStyle), err
}

func (l libraryStyleDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.LibraryStyle, err error) {
	buf := make([]*model.LibraryStyle, 0, batchSize)
	err = l.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (l libraryStyleDo) FindInBatches(result *[]*model.LibraryStyle, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return l.DO.FindInBatches(result, batchSize, fc)
}

func (l libraryStyleDo) Attrs(attrs ...field.AssignExpr) ILibraryStyleDo {
	return l.withDO(l.DO.Attrs(attrs...))
}

func (l libraryStyleDo) Assign(attrs ...field.AssignExpr) ILibraryStyleDo {
	return l.withDO(l.DO.Assign(attrs...))
}

func (l libraryStyleDo) Joins(fields ...field.RelationField) ILibraryStyleDo {
	for _, _f := range fields {
		l = *l.withDO(l.DO.Joins(_f))
	}
	return &l
}

func (l libraryStyleDo) Preload(fields ...field.RelationField) ILibraryStyleDo {
	for _, _f := range fields {
		l = *l.withDO(l.DO.Preload(_f))
	}
	return &l
}

func (l libraryStyleDo) FirstOrInit() (*model.LibraryStyle, error) {
	if result, err := l.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.LibraryStyle), nil
	}
}

func (l libraryStyleDo) FirstOrCreate() (*model.LibraryStyle, error) {
	if result, err := l.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.LibraryStyle), nil
	}
}

func (l libraryStyleDo) FindByPage(offset int, limit int) (result []*model.LibraryStyle, count int64, err error) {
	result, err = l.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = l.Offset(-1).Limit(-1).Count()
	return
}

func (l libraryStyleDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = l.Count()
	if err != nil {
		return
	}

	err = l.Offset(offset).Limit(limit).Scan(result)
	return
}

func (l libraryStyleDo) Scan(result interface{}) (err error) {
	return l.DO.Scan(result)
}

func (l libraryStyleDo) Delete(models ...*model.LibraryStyle) (result gen.ResultInfo, err error) {
	return l.DO.Delete(models)
}

func (l *libraryStyleDo) withDO(do gen.Dao) *libraryStyleDo {
	l.DO = *do.(*gen.DO)
	return l
}
