// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package models

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"glm-go-project/model"
)

func newMapProject(db *gorm.DB, opts ...gen.DOOption) mapProject {
	_mapProject := mapProject{}

	_mapProject.mapProjectDo.UseDB(db, opts...)
	_mapProject.mapProjectDo.UseModel(&model.MapProject{})

	tableName := _mapProject.mapProjectDo.TableName()
	_mapProject.ALL = field.NewAsterisk(tableName)
	_mapProject.ID = field.NewInt32(tableName, "id")
	_mapProject.DateCreate = field.NewTime(tableName, "date_create")
	_mapProject.DateLastChange = field.NewTime(tableName, "date_last_change")
	_mapProject.CreaterID = field.NewInt64(tableName, "creater_id")
	_mapProject.ChangerID = field.NewInt64(tableName, "changer_id")
	_mapProject.IsArchive = field.NewBool(tableName, "is_archive")
	_mapProject.Title = field.NewString(tableName, "title")
	_mapProject.CenterLat = field.NewFloat64(tableName, "center_lat")
	_mapProject.CenterLng = field.NewFloat64(tableName, "center_lng")
	_mapProject.DefaultZoom = field.NewInt16(tableName, "default_zoom")
	_mapProject.TileDefaultID = field.NewInt32(tableName, "tile_default_id")
	_mapProject.CoordinateSystemID = field.NewInt32(tableName, "coordinate_system_id")
	_mapProject.MarkerClusterGroupZoom = field.NewInt32(tableName, "marker_cluster_group_zoom")
	_mapProject.WmsProjectMapserver = field.NewString(tableName, "wms_project_mapserver")
	_mapProject.ColorFilter = field.NewString(tableName, "color_filter")
	_mapProject.IsWmsMerge = field.NewBool(tableName, "is_wms_merge")
	_mapProject.IsWmsCache = field.NewBool(tableName, "is_wms_cache")
	_mapProject.Settings = field.NewString(tableName, "settings")
	_mapProject.Description = field.NewString(tableName, "description")
	_mapProject.Image = field.NewString(tableName, "image")
	_mapProject.IsTemplate = field.NewBool(tableName, "is_template")

	_mapProject.fillFieldMap()

	return _mapProject
}

type mapProject struct {
	mapProjectDo

	ALL                    field.Asterisk
	ID                     field.Int32
	DateCreate             field.Time
	DateLastChange         field.Time
	CreaterID              field.Int64
	ChangerID              field.Int64
	IsArchive              field.Bool
	Title                  field.String
	CenterLat              field.Float64
	CenterLng              field.Float64
	DefaultZoom            field.Int16
	TileDefaultID          field.Int32
	CoordinateSystemID     field.Int32
	MarkerClusterGroupZoom field.Int32
	WmsProjectMapserver    field.String
	ColorFilter            field.String
	IsWmsMerge             field.Bool
	IsWmsCache             field.Bool
	Settings               field.String
	Description            field.String
	Image                  field.String
	IsTemplate             field.Bool

	fieldMap map[string]field.Expr
}

func (m mapProject) Table(newTableName string) *mapProject {
	m.mapProjectDo.UseTable(newTableName)
	return m.updateTableName(newTableName)
}

func (m mapProject) As(alias string) *mapProject {
	m.mapProjectDo.DO = *(m.mapProjectDo.As(alias).(*gen.DO))
	return m.updateTableName(alias)
}

func (m *mapProject) updateTableName(table string) *mapProject {
	m.ALL = field.NewAsterisk(table)
	m.ID = field.NewInt32(table, "id")
	m.DateCreate = field.NewTime(table, "date_create")
	m.DateLastChange = field.NewTime(table, "date_last_change")
	m.CreaterID = field.NewInt64(table, "creater_id")
	m.ChangerID = field.NewInt64(table, "changer_id")
	m.IsArchive = field.NewBool(table, "is_archive")
	m.Title = field.NewString(table, "title")
	m.CenterLat = field.NewFloat64(table, "center_lat")
	m.CenterLng = field.NewFloat64(table, "center_lng")
	m.DefaultZoom = field.NewInt16(table, "default_zoom")
	m.TileDefaultID = field.NewInt32(table, "tile_default_id")
	m.CoordinateSystemID = field.NewInt32(table, "coordinate_system_id")
	m.MarkerClusterGroupZoom = field.NewInt32(table, "marker_cluster_group_zoom")
	m.WmsProjectMapserver = field.NewString(table, "wms_project_mapserver")
	m.ColorFilter = field.NewString(table, "color_filter")
	m.IsWmsMerge = field.NewBool(table, "is_wms_merge")
	m.IsWmsCache = field.NewBool(table, "is_wms_cache")
	m.Settings = field.NewString(table, "settings")
	m.Description = field.NewString(table, "description")
	m.Image = field.NewString(table, "image")
	m.IsTemplate = field.NewBool(table, "is_template")

	m.fillFieldMap()

	return m
}

func (m *mapProject) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := m.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (m *mapProject) fillFieldMap() {
	m.fieldMap = make(map[string]field.Expr, 21)
	m.fieldMap["id"] = m.ID
	m.fieldMap["date_create"] = m.DateCreate
	m.fieldMap["date_last_change"] = m.DateLastChange
	m.fieldMap["creater_id"] = m.CreaterID
	m.fieldMap["changer_id"] = m.ChangerID
	m.fieldMap["is_archive"] = m.IsArchive
	m.fieldMap["title"] = m.Title
	m.fieldMap["center_lat"] = m.CenterLat
	m.fieldMap["center_lng"] = m.CenterLng
	m.fieldMap["default_zoom"] = m.DefaultZoom
	m.fieldMap["tile_default_id"] = m.TileDefaultID
	m.fieldMap["coordinate_system_id"] = m.CoordinateSystemID
	m.fieldMap["marker_cluster_group_zoom"] = m.MarkerClusterGroupZoom
	m.fieldMap["wms_project_mapserver"] = m.WmsProjectMapserver
	m.fieldMap["color_filter"] = m.ColorFilter
	m.fieldMap["is_wms_merge"] = m.IsWmsMerge
	m.fieldMap["is_wms_cache"] = m.IsWmsCache
	m.fieldMap["settings"] = m.Settings
	m.fieldMap["description"] = m.Description
	m.fieldMap["image"] = m.Image
	m.fieldMap["is_template"] = m.IsTemplate
}

func (m mapProject) clone(db *gorm.DB) mapProject {
	m.mapProjectDo.ReplaceConnPool(db.Statement.ConnPool)
	return m
}

func (m mapProject) replaceDB(db *gorm.DB) mapProject {
	m.mapProjectDo.ReplaceDB(db)
	return m
}

type mapProjectDo struct{ gen.DO }

type IMapProjectDo interface {
	gen.SubQuery
	Debug() IMapProjectDo
	WithContext(ctx context.Context) IMapProjectDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IMapProjectDo
	WriteDB() IMapProjectDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IMapProjectDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IMapProjectDo
	Not(conds ...gen.Condition) IMapProjectDo
	Or(conds ...gen.Condition) IMapProjectDo
	Select(conds ...field.Expr) IMapProjectDo
	Where(conds ...gen.Condition) IMapProjectDo
	Order(conds ...field.Expr) IMapProjectDo
	Distinct(cols ...field.Expr) IMapProjectDo
	Omit(cols ...field.Expr) IMapProjectDo
	Join(table schema.Tabler, on ...field.Expr) IMapProjectDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IMapProjectDo
	RightJoin(table schema.Tabler, on ...field.Expr) IMapProjectDo
	Group(cols ...field.Expr) IMapProjectDo
	Having(conds ...gen.Condition) IMapProjectDo
	Limit(limit int) IMapProjectDo
	Offset(offset int) IMapProjectDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IMapProjectDo
	Unscoped() IMapProjectDo
	Create(values ...*model.MapProject) error
	CreateInBatches(values []*model.MapProject, batchSize int) error
	Save(values ...*model.MapProject) error
	First() (*model.MapProject, error)
	Take() (*model.MapProject, error)
	Last() (*model.MapProject, error)
	Find() ([]*model.MapProject, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.MapProject, err error)
	FindInBatches(result *[]*model.MapProject, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.MapProject) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IMapProjectDo
	Assign(attrs ...field.AssignExpr) IMapProjectDo
	Joins(fields ...field.RelationField) IMapProjectDo
	Preload(fields ...field.RelationField) IMapProjectDo
	FirstOrInit() (*model.MapProject, error)
	FirstOrCreate() (*model.MapProject, error)
	FindByPage(offset int, limit int) (result []*model.MapProject, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IMapProjectDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (m mapProjectDo) Debug() IMapProjectDo {
	return m.withDO(m.DO.Debug())
}

func (m mapProjectDo) WithContext(ctx context.Context) IMapProjectDo {
	return m.withDO(m.DO.WithContext(ctx))
}

func (m mapProjectDo) ReadDB() IMapProjectDo {
	return m.Clauses(dbresolver.Read)
}

func (m mapProjectDo) WriteDB() IMapProjectDo {
	return m.Clauses(dbresolver.Write)
}

func (m mapProjectDo) Session(config *gorm.Session) IMapProjectDo {
	return m.withDO(m.DO.Session(config))
}

func (m mapProjectDo) Clauses(conds ...clause.Expression) IMapProjectDo {
	return m.withDO(m.DO.Clauses(conds...))
}

func (m mapProjectDo) Returning(value interface{}, columns ...string) IMapProjectDo {
	return m.withDO(m.DO.Returning(value, columns...))
}

func (m mapProjectDo) Not(conds ...gen.Condition) IMapProjectDo {
	return m.withDO(m.DO.Not(conds...))
}

func (m mapProjectDo) Or(conds ...gen.Condition) IMapProjectDo {
	return m.withDO(m.DO.Or(conds...))
}

func (m mapProjectDo) Select(conds ...field.Expr) IMapProjectDo {
	return m.withDO(m.DO.Select(conds...))
}

func (m mapProjectDo) Where(conds ...gen.Condition) IMapProjectDo {
	return m.withDO(m.DO.Where(conds...))
}

func (m mapProjectDo) Order(conds ...field.Expr) IMapProjectDo {
	return m.withDO(m.DO.Order(conds...))
}

func (m mapProjectDo) Distinct(cols ...field.Expr) IMapProjectDo {
	return m.withDO(m.DO.Distinct(cols...))
}

func (m mapProjectDo) Omit(cols ...field.Expr) IMapProjectDo {
	return m.withDO(m.DO.Omit(cols...))
}

func (m mapProjectDo) Join(table schema.Tabler, on ...field.Expr) IMapProjectDo {
	return m.withDO(m.DO.Join(table, on...))
}

func (m mapProjectDo) LeftJoin(table schema.Tabler, on ...field.Expr) IMapProjectDo {
	return m.withDO(m.DO.LeftJoin(table, on...))
}

func (m mapProjectDo) RightJoin(table schema.Tabler, on ...field.Expr) IMapProjectDo {
	return m.withDO(m.DO.RightJoin(table, on...))
}

func (m mapProjectDo) Group(cols ...field.Expr) IMapProjectDo {
	return m.withDO(m.DO.Group(cols...))
}

func (m mapProjectDo) Having(conds ...gen.Condition) IMapProjectDo {
	return m.withDO(m.DO.Having(conds...))
}

func (m mapProjectDo) Limit(limit int) IMapProjectDo {
	return m.withDO(m.DO.Limit(limit))
}

func (m mapProjectDo) Offset(offset int) IMapProjectDo {
	return m.withDO(m.DO.Offset(offset))
}

func (m mapProjectDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IMapProjectDo {
	return m.withDO(m.DO.Scopes(funcs...))
}

func (m mapProjectDo) Unscoped() IMapProjectDo {
	return m.withDO(m.DO.Unscoped())
}

func (m mapProjectDo) Create(values ...*model.MapProject) error {
	if len(values) == 0 {
		return nil
	}
	return m.DO.Create(values)
}

func (m mapProjectDo) CreateInBatches(values []*model.MapProject, batchSize int) error {
	return m.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (m mapProjectDo) Save(values ...*model.MapProject) error {
	if len(values) == 0 {
		return nil
	}
	return m.DO.Save(values)
}

func (m mapProjectDo) First() (*model.MapProject, error) {
	if result, err := m.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.MapProject), nil
	}
}

func (m mapProjectDo) Take() (*model.MapProject, error) {
	if result, err := m.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.MapProject), nil
	}
}

func (m mapProjectDo) Last() (*model.MapProject, error) {
	if result, err := m.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.MapProject), nil
	}
}

func (m mapProjectDo) Find() ([]*model.MapProject, error) {
	result, err := m.DO.Find()
	return result.([]*model.MapProject), err
}

func (m mapProjectDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.MapProject, err error) {
	buf := make([]*model.MapProject, 0, batchSize)
	err = m.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (m mapProjectDo) FindInBatches(result *[]*model.MapProject, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return m.DO.FindInBatches(result, batchSize, fc)
}

func (m mapProjectDo) Attrs(attrs ...field.AssignExpr) IMapProjectDo {
	return m.withDO(m.DO.Attrs(attrs...))
}

func (m mapProjectDo) Assign(attrs ...field.AssignExpr) IMapProjectDo {
	return m.withDO(m.DO.Assign(attrs...))
}

func (m mapProjectDo) Joins(fields ...field.RelationField) IMapProjectDo {
	for _, _f := range fields {
		m = *m.withDO(m.DO.Joins(_f))
	}
	return &m
}

func (m mapProjectDo) Preload(fields ...field.RelationField) IMapProjectDo {
	for _, _f := range fields {
		m = *m.withDO(m.DO.Preload(_f))
	}
	return &m
}

func (m mapProjectDo) FirstOrInit() (*model.MapProject, error) {
	if result, err := m.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.MapProject), nil
	}
}

func (m mapProjectDo) FirstOrCreate() (*model.MapProject, error) {
	if result, err := m.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.MapProject), nil
	}
}

func (m mapProjectDo) FindByPage(offset int, limit int) (result []*model.MapProject, count int64, err error) {
	result, err = m.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = m.Offset(-1).Limit(-1).Count()
	return
}

func (m mapProjectDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = m.Count()
	if err != nil {
		return
	}

	err = m.Offset(offset).Limit(limit).Scan(result)
	return
}

func (m mapProjectDo) Scan(result interface{}) (err error) {
	return m.DO.Scan(result)
}

func (m mapProjectDo) Delete(models ...*model.MapProject) (result gen.ResultInfo, err error) {
	return m.DO.Delete(models)
}

func (m *mapProjectDo) withDO(do gen.Dao) *mapProjectDo {
	m.DO = *do.(*gen.DO)
	return m
}
